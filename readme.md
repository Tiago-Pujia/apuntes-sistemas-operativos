# üìò Introducci√≥n

> Material de cursada de la materia **Sistemas Operativos**  
> üìÖ Inicio: 09/04/2025  
> üéì Alumno: Tiago Pujia | üë®‚Äçüè´ Prof: Alexis Villamayor  
> üïî Comisi√≥n 3900 [3 = Miercoles, 9 = Turno noche]
> ‚ñ∂Ô∏è [Clases Grabadas](https://www.youtube.com/)

## Indice

- [üìò Introducci√≥n](#-introducci√≥n)
  - [Indice](#indice)
- [Clase 1 y 2 - Modulo 1: Introducci√≥n a los Sistemas Operativos](#clase-1-y-2---modulo-1-introducci√≥n-a-los-sistemas-operativos)
  - [¬øQue es un sistema operativo?](#que-es-un-sistema-operativo)
    - [¬øPor qu√© estudiar los sistemas operatiovs?](#por-qu√©-estudiar-los-sistemas-operatiovs)
  - [Funciones y Objetivos](#funciones-y-objetivos)
    - [Inicializaci√≥n (proceso de arranque)](#inicializaci√≥n-proceso-de-arranque)
    - [Maquina Extendida (Interfaz)](#maquina-extendida-interfaz)
    - [Administraci√≥n de recursos](#administraci√≥n-de-recursos)
    - [Aislamiento](#aislamiento)
    - [Seguridad](#seguridad)
  - [Clasificaciones de Sistemas Operativos](#clasificaciones-de-sistemas-operativos)
    - [Segun la Cantidad de Usuarios](#segun-la-cantidad-de-usuarios)
    - [Segun la Cantidad de Procesadores que Soporta](#segun-la-cantidad-de-procesadores-que-soporta)
    - [Segun la Cantidad de Tareas que Sucesivas](#segun-la-cantidad-de-tareas-que-sucesivas)
    - [Segun sus Aplicaciones (Usos)](#segun-sus-aplicaciones-usos)
    - [Segun la Organizaci√≥n de su Arquitectura](#segun-la-organizaci√≥n-de-su-arquitectura)
  - [Interrupciones](#interrupciones)
    - [Definici√≥n](#definici√≥n)
    - [Clasificaci√≥n](#clasificaci√≥n)
      - [Segun prioridad](#segun-prioridad)
      - [Segun su origen](#segun-su-origen)
    - [Diferencia Interrupci√≥n y Excepci√≥n](#diferencia-interrupci√≥n-y-excepci√≥n)
    - [Funciones y Objetivos](#funciones-y-objetivos-1)
  - [Modos de Ejecucion de los Procesos](#modos-de-ejecucion-de-los-procesos)
  - [Definiciones Computo Distribuido](#definiciones-computo-distribuido)
- [Clase 3](#clase-3)
  - [Modulo 2: De Programas a Procesos](#modulo-2-de-programas-a-procesos)
    - [Conceptos Basicos](#conceptos-basicos)
    - [Entidad Pasiva y Activa](#entidad-pasiva-y-activa)
    - [Compilaci√≥n y Carga de un Proceso](#compilaci√≥n-y-carga-de-un-proceso)
    - [Procesos y Thread](#procesos-y-thread)
    - [Administraci√≥n de Procesos](#administraci√≥n-de-procesos)
      - [Estructura Memoria CPU](#estructura-memoria-cpu)
      - [Bloque de Control (PCB)](#bloque-de-control-pcb)
      - [Cambio de Contexto y Proceso](#cambio-de-contexto-y-proceso)
      - [Objetivos del PCB](#objetivos-del-pcb)
      - [Contenido del PCB](#contenido-del-pcb)
    - [Transici√≥n de Estados de un Proceso](#transici√≥n-de-estados-de-un-proceso)
      - [Tipos de Estados](#tipos-de-estados)
      - [Diagrama de Proceso](#diagrama-de-proceso)
        - [Modelo 7 Estados](#modelo-7-estados)
        - [Modelo 5 Estados](#modelo-5-estados)
      - [Colas](#colas)
      - [Clasificaci√≥n Estados](#clasificaci√≥n-estados)
      - [Razones de un Cambio de Estado de Proceso](#razones-de-un-cambio-de-estado-de-proceso)
    - [Creaci√≥n de Procesos](#creaci√≥n-de-procesos)
      - [Razones para crear un proceso](#razones-para-crear-un-proceso)
      - [Tipos de Creacion de Procesos](#tipos-de-creacion-de-procesos)
      - [Secuencia de creaci√≥n de un proceso](#secuencia-de-creaci√≥n-de-un-proceso)
      - [Finalizar de un proceso](#finalizar-de-un-proceso)
    - [Hilos](#hilos)
      - [Definici√≥n](#definici√≥n-1)
      - [Ventajas respecto a los Procesos](#ventajas-respecto-a-los-procesos)
      - [Implementaci√≥n de Hilos](#implementaci√≥n-de-hilos)
        - [Hilos a Nivel de Usuario (ULT)](#hilos-a-nivel-de-usuario-ult)
        - [Hilos a Nivel de Kernel](#hilos-a-nivel-de-kernel)
      - [Estado de los Hilos](#estado-de-los-hilos)
      - [Estructuras de Uso de los Hilos](#estructuras-de-uso-de-los-hilos)
  - [Modulo 3: Planificaci√≥n de Procesos](#modulo-3-planificaci√≥n-de-procesos)
    - [Concepto de Planificaci√≥n](#concepto-de-planificaci√≥n)
    - [Objetivos](#objetivos)
    - [Tipos](#tipos)
    - [Tipos de procesos](#tipos-de-procesos)

# Clase 1 y 2 - Modulo 1: Introducci√≥n a los Sistemas Operativos

## ¬øQue es un sistema operativo?

Definiciones dadas por el profesor sobre s.o:

> Conjunto de m√≥dulos o funciones (software), que, instalados en la computadora, se ocupan de controlar y administrar la ejecuci√≥n de los programas sobre los recursos que brinda el equipo (hardware), tales como: memoria, procesador, perif√©ricos, etc.

> Conjunto de programas que ordenadamente relacionados entre s√≠, contribuyen a que la computadora lleve a cabo correctamente su trabajo para nosotros en un ambiente dado.

El **kernel** es el n√∫cleo del sistema operativo. Es la parte m√°s importante, encargada de: administrar hardware,

### ¬øPor qu√© estudiar los sistemas operatiovs?

No s√≥lo en comprender los mecanismos de los mismos. Si no, entenderlos para evitar los errores m√°s comunes al programar o aumentar la seguridad del sistema operativo.

## Funciones y Objetivos

El sistema operativo es el √∫nico programa que interactua directamente con el hardware. Sus funciones primarias son:

### Inicializaci√≥n (proceso de arranque)

![inicializacion](/imgs/clase-1/inicializador.png)

Al encender una computadora, se ejecuta un **chequeo inicial**, controlado por el firmware de la placa madre, ya sea **_BIOS_** o **_UEFI_**. Este proceso se encarga de inicializar y verificar el hardware esencial (como la memoria RAM, el procesador y los discos). Adem√°s, permite al usuario acceder a una interfaz de configuraci√≥n, donde puede definir opciones como el orden de arranque.

Una vez completado este chequeo, el BIOS o UEFI busca un **dispositivo de almacenamiento** que contenga un **_MBR (Master Boot Record)_** v√°lido. Este MBR se encuentra en el **primer sector f√≠sico del disco** (sector 0). En √©l se almacena una peque√±a parte del **c√≥digo de arranque**.

El BIOS transfiere el control al c√≥digo ubicado en el MBR, el cual se encarga de identificar la **_partici√≥n activa_**, es decir, aquella que est√° marcada como booteable. Desde all√≠, el MBR accede al sector de arranque de dicha partici√≥n, donde se encuentra un puntero que lo dirige al **_gestor de arranque_** o **_bootloader_**.

El **_bootloader_** es un programa almacenado dentro del sistema de archivos del disco. Su funci√≥n es **cargar el n√∫cleo del sistema operativo (kernel)** en la **memoria RAM** y dar inicio a la ejecuci√≥n del sistema, dejando el entorno preparado para que el usuario comience a trabajar.

### Maquina Extendida (Interfaz)

Procedimiento que permite la interacci√≥n del usuario con el ordenador. Sus principales funciones:

-   Facilita comunicaci√≥n con el usuario
-   Aceptar entradas de nuevos trabajos
-   Abstracci√≥n: los programas no deben preocuparse de los detalles de acceso a hardware o de la configuraci√≥n

Existen diferentes clasificaci√≥n en las interfaces:

-   GUI (Grafica para Usuarios) -> KDE, Gnome, Aero
-   CLI (Linea de Comandos) -> Bash, cmd, powershell
-   NUI (Interfaz superior a la grafica) -> tactil, voz, gestos

### Administraci√≥n de recursos

-   Mas del 70% del s.o esta dedicado a esta funci√≥n
-   Gestiona politicas de asignaci√≥n de recursos para que los programas no compitan por los ellos
-   Optimiza los recursos

### Aislamiento

En un sistema multiusuario y multitarea, cada proceso y cada usuario no tendra que preocuparse por otros que esten usando el mismo sistema.

### Seguridad

Garantizar la integridad de los recursos y procesos como, tambien validar los usuarios del sistema. Existen 2 modos para lograrlo:

-   Modo dual de ejecuci√≥n del procesador - > separa en 2 tipos de instrucciones
    -   Modo usuario o no privilegiado
    -   Mood kernel o privilegiado (uso exclusivo para el s.o)
-   Juego de instrucciones diferenciadas del procesador

Si un usuario quiere usar instrucciones de kernel entra en un trap.

La seguridad se basa en 3 caracteristicas:

-   **Abstracci√≥n** -> Un usuario no puede escribir directo en el disco, su acceso debe estar limitado a la interfaz
-   **Administrar Recuersos** -> Politica de asignaci√≥n de recursos
-   **Aislamiento** -> Si el S.O ofrece separaci√≥n entre los datros, procesos y recursos de distintos usuarios. Ninguno debe tener acceso a la informaci√≥n del projimo.

## Clasificaciones de Sistemas Operativos

### Segun la Cantidad de Usuarios

-   **Monousuario** -> Un solo usuario
-   **Multiusuario** -> Varios usuarios (incluyendo remeto)

### Segun la Cantidad de Procesadores que Soporta

-   **Uniprocesador** -> Solo puede manejar un procesador de la computadora. Por lo que si tiene mas de un nucleo el cpu, es inutil.
-   **Multiprocesador** -> Sistemas capaces de manejar mas de un procesador

### Segun la Cantidad de Tareas que Sucesivas

-   **Monoprogramado o monotarea** -> Solo se puede ejecutar un proceso a la vez recien cuando finalize uno, arranca el siguiente.
-   **Multiprogramado(multitarea)** -> Mas de un proceso ejecutando el sistema

### Segun sus Aplicaciones (Usos)

-   **Proposito general** -> Propositos de amplia gama con cualquier fin
-   **Proposito especial** -> construccion a medida para un uso especifico. Se clasifica en:
    -   Tiempo real -> Tiempo de respuesta a eventos
        -   Tiempo Real No Cr√≠tico -> El tiempo de respuesta es importante, pero no vital
        -   Tiempo Real Cr√≠tico -> Requiere una respuesta inmediata
    -   Tolerante a fallas -> Se utilizan en aplicaciones donde es fundamental mantener un servicio continuo, incluso ante fallos de hardware o software. El mismo S.O detecta y corrige errores.
    -   Sistemas virtuales -> Los Sistemas Operativos Virtuales son capaces de administrar y gestionar otros sistemas operativos que se ejecutan de forma concurrente sobre el mismo hardware.

### Segun la Organizaci√≥n de su Arquitectura

Existen 2 formas principales de organizaci√≥n del n√∫cleo de un sistema operativo, junto a un enfoque h√≠brido:

-   **Monoliticos**

Todo el sistema operativo corre como un √∫nico proceso privilegiado que opera como supervisor. Todas las funcionalidades (gesti√≥n de memoria, archivos, dispositivos, etc.) est√°n integradas directamente en el n√∫cleo.

Ventajas:

-   Simplifica gran cantidad de mecanismos -> mayor velocidad ejecuci√≥n
-   Mayor flexibilidad

![monolitico](imgs/clase-1/monolitico.png)

-   **MicroKernel**

El n√∫cleo se mantiene en el minimo posible de funcionalidad, descargando en procesos especiales sin privilegios las tareas que implementan el acceso a dispositivos y las diversas politicas de uso del sistema. Se limita a las funciones m√°s b√°sicas (como planificaci√≥n y comunicaci√≥n).

Ventajas:

-   Esquema logico mas limpio
-   Implementaciones mas elegantes y faciles de comprender
-   Puede auto-repararse

![microkernel](imgs/clase-1/microkernel.png)

-   **Hibridos**

Sistemas que son mayormente monolitocs pero que manejan algunos procesos que parecerian centrales mediante de procesos de nivel de usuario como microkernel.

La mayor√≠a de los S.O. modernos, como Windows, adoptan este modelo por su equilibrio entre rendimiento y flexibilidad.

![hibrido](imgs/clase-1/hibrido.png)

## Interrupciones

### Definici√≥n

Cuando ocurra alg√∫n evento que requiere la atenci√≥n del sistema operativo, el mismo levanta la solicitud y detiene el proceso que estaba siendo ejecutado. El S.O ejecuta su rutina de manejo de interrupciones y atiende la interrupci√≥n. Las mismas se pueden organizar por orden de prioridad y hay un numero limitado.

### Clasificaci√≥n

#### Segun prioridad

-   **No Enmascarable (no postergar)** -> Debe ser atentido si o si en el momento
-   **Enmascarable (postergar)** -> No es urgente y se atiende cuando quiere

#### Segun su origen

-   **Software** -> llamadas del sistema (syscalls)
-   **Harware** -> llamadas por un componente fisico. Se subdivide en:
    -   Interno -> Dentro del procesador. Ejemplo: divisioon por cero, acceso no autorizado a memoria.
    -   Externo -> Fuera del procesador. Ejemplo: ingreso por teclado, un pendrive co

### Diferencia Interrupci√≥n y Excepci√≥n

-   **Interrupci√≥n** -> Causas externas a la computadora
-   **Excepci√≥n** -> Causado por un proceso interno

### Funciones y Objetivos

-   **Administrar el hawrdawre manejando interrupciones**
-   **Abstraer las Interrupciones** -> Oculta al programa de usuario que ocurren interrupociones de hardware. Pero, avisa al usuario mediante mensajes, se√±ales o deteniendo el proceso.
-   **Atender Excepciones y Fallas** -> Durante la ejecuci√≥n de un programa, ocurre situaciones an√≥males
-   **Punto de entrada al Sistema Operativo** -> Medio por el cual un proceso realiza una llamada al sistema (ecall de Assembly). Estas llamadas sirven para:
    -   **Control de Procesos** -> crear o finalizar proceso, asignar o liberar memoria, etc...
    -   **Manipular Archivos** -> Crear, borrar o renombrar un archivo
    -   **Manipulaci√≥n de Dispositivos** -> Solicitar o liberar un dispositiovo
    -   **Manipular Informaci√≥n** -> Obtener o modificar la hora del sistema, pedir detalles acerca de procesos o archivos
    -   **Comunicaciones** -> Establecer una comunicaci√≥n con determinado proceso (local o remoto)
    -   **Protecci√≥n** -> Consultar o modificar la informaci√≥n relativa al acceso de objetos en el disco o sesi√≥n del usuario.

Las llamadas al sistema son expuestas al programador mediante las *interfaces de apliacaci√≥n al programador*(API).

## Modos de Ejecucion de los Procesos

![](/imgs/clase-1/ejecucion-programacion.png)

-   **Procesos Secuenciales** -> Cada proceso se ejecuta a continuaci√≥n del otro
-   **Multiprogramaci√≥n** -> Ilusion que se ejecutan varios procesos al mismo tiempo, pero en realidad esta alternando entre los diversos procesos que compiten por su atenci√≥n. Por lo que, atiende simultaneamente diversos procesos.
-   **Multiprocesamiento** -> Entorno donde hay mas de un procesador (CPU). Por lo que diferentes procesos independientes se ejecutan en paralelo.
    -   **Asim√©trico** -> Procesadores con arquitecturas distintas. Tambien se pueden llamar como coprocesaodres o procesadores coadyuvantes.
    -   **Sim√©trico** -> Todos los CPU son iguales y pueden realizar en el mismo tiempo las operaciones
        -   Unifrm Memory Access(UMA) -> Ambos procesadores comparten la memoria, utilizan un BUS compartido
        -   Non-Uniform Memory Access(NUMA) -> Cada procesador tiene bancos de memoria. Da como ventajas que es mas rapido.
-   **Hibrido** -> Multiprogramaci√≥n y Multiprocesamiento se combinan. Las mayorias de PC funcionan asi.

## Definiciones Computo Distribuido

Proceso de c√≥mputo realizado entre computadoras independientes, o tambien dicho, entre procesadores que no comparten memoria. Hay diferentes implementaciones:

-   **C√∫mulos(Clusters)** -> Computadoras conectadas por una red local. La red es administrado por un software.
-   **Mallas (Grids)** -> Computadoras distribuidas a nivel geografico e interconectadas a una red.
-   **C√≥mputo En la Nube** -> Tercerizaci√≥n de servicios; la implementaci√≥n de servicios deja de ser relevante. Se aplica conceptos como:
    -   Servicios Web
    -   Software como Servicio
    -   Plataforma como Servicio
    -   Infraestructura como Servicio

# Clase 3

## Modulo 2: De Programas a Procesos

### Conceptos Basicos

- **¬øQue es un Programa?**

> Conjunto de instrucciones que resuelven un problema

- **¬øQue es una Instrucci√≥n?**

> Unidad de ejecuci√≥n que dura un tiempo finito y se ejecuta sobre un procesador. No se descompone ni interrumpe

- **¬øQue es un Proceso?**

> Porcion de un programa cargando en memoria central al cual se le asocia su contexto de ejecucion (run time environment) mediante una estructura de datos llamada vector de estado o **Bloque de Control del Proceso (PCB)**

### Entidad Pasiva y Activa

- **Entidad Pasiva**

No cambia por si mismo, no tiene actividad propia, solo es un conjunto de instrucciones a ser esperado. Ejemplo: Un programa almacenado en disco o memoria.

- **Entidad Activa**

Cambia de estado mientras se ejecuta, tiene actividad propia (consume CPU, E/S y memoria). Ejemplo: Un proceso en ejecucion

### Compilaci√≥n y Carga de un Proceso

![](/imgs/clase-2/Compilaci√≥n%20y%20Carga%20de%20un%20Proceso.png)

1. **Primer Paso: Traduccion de codigo fuente a maquina**
    1. Se parte de un programa fuente, donde escribimos el c√≥digo en un lenguaje de alto nivel.
    2. Se compila y entrega:
           - Area de texto: Instrucciones traducidas a codigo maquina
           - Tabla de Simbolos: Asocia las variables del programa a direcciones de memoria relativas al origen. Guarda:
             - Nombre del simbolo o identificador (nombre variable)
             - Direccion inicio variable
             - Direccion fin Variable
    3. El **Programa Objeto** es el resultado. Archivo binario con instrucciones pero sin estar listo para ejecutarse.
2. **Segundo Paso: Link-Editor (enlazador) Resuelve referencias externas del programa objeto para transformarlo a programa ejecutable**
    1. El link-editor labura sobre el programa objeto:
       - Incluye librerias
       - Combina todos los programas objetos en uno solo
       - Ajusta las direcciones de memoria, asignando identificadores √∫nicos a las variables y funciones.
    2. Da como resultado un programa ejecutable preparador para ser cargado a memoria.
3. **Tercer Paso: Ubica el programa ejecutable a memoria**
    1. Lee el archivo ejecutable
    2. Lo ubica en una posici√≥n libre de la memoria principal.
    3. Genera el PCB (Process Control Block); Estructura que almacenar√° toda la informaci√≥n necesaria para administrar el proceso(estado, registros, contador de programa, etc.).
4. **Cuarto Paso: Proceso en estado de ejecutarse**

### Procesos y Thread

- **Procesos**
Un proceso se define como la imagen de un programa en ejecucion; en memoria usando la CPU. A esta altura, un proceso tiene un espacio de direcciones de memoria, una pila, regitros y program counter (PC)

- **Hilo(thread) o Proceso Liviano**
Dentro de un proceso se puede tener secciones que tienen sus propios procesos, osea su propio espacio de memoria, registros, pila y program counter. Puede compartir memoria con el resto de thread que forman parte del mismo proceso.

### Administraci√≥n de Procesos

#### Estructura Memoria CPU

![](/imgs/clase-2/memoria-cpu.png)

1. **Stack(pila):** √Årea utilizado para almacenar informaci√≥n asociada a la ejecuci√≥n de funciones. Ejemplo: Variables locales, parametros funciones, direcciones retorno
2. **Dynamic Data(heap):** Almacena datos de tama√±o variable o datos que se crean din√°micamente en tiempo de ejecuci√≥n. Ejemplo: malloc, realloc, free
3. **Static Data:** Datos de longitud fija creador en tiempo de compilacion. Ejemplo: variables globales y constantes
4. **Literales:** Area de texto para datos constantes. Ejemplo: "Hola"
5. **Instrucciones:** Area de texto donde guarda instrucciones del programa. Solo de lectura

#### Bloque de Control (PCB)

Los datos de **cada** proceso se guardan en un PCB propio. Este, se almacena en la pila del procesador. Del stack se copia una imagen del proceso que se carga al CPU y se ejecuta.

En el PCB se guarda para cada proceso, la informaci√≥n necesaria para reanurlo en caso que sea suspendido o desalojado. A esto se le llama cambio de contexto.

#### Cambio de Contexto y Proceso

- **Cambio de Contexto**

Mecanismo mediante el cual el Sistema Operativo guarda el estado actual de la CPU (registros, contador de programa, etc.) asociado al proceso en ejecuci√≥n, para luego cargar el estado de otro proceso que debe ejecutarse

El cambio de contexto permite interrumpir un proceso y continuarlo m√°s adelante desde el mismo punto donde qued√≥.

- **Cambio de Proceso**

Ocurre cuando el Sistema Operativo decide suspender el proceso actual y darle la CPU a otro proceso diferenteo. El cambio se puede dar por distintos motivos, por ejemplo: Finalizaci√≥n de una tarea, Interrupciones del sistema.

Implica necesariamente hacer un cambio de contexto: primero se guarda el estado del proceso que se suspende y luego se carga el estado del nuevo proceso.

- **Diferencia**

| Concepto             | ¬øQu√© hace?                                             | ¬øCu√°ndo ocurre?                             |
|-----------------------|---------------------------------------------------------|---------------------------------------------|
| **Cambio de Contexto** | Guarda el estado de un proceso y carga el de otro.      | Cada vez que se cambia el proceso en ejecuci√≥n. |
| **Cambio de Proceso**  | Elige otro proceso para ejecutar.                      | Cuando el sistema operativo lo decide (fin de proceso, interrupci√≥n, planificaci√≥n, etc.). |


#### Objetivos del PCB

- Localizaci√≥n de la informaci√≥n sobre el proceso por parte del S.O
- Mantener registrados los datos del proceso en caso de suspender la ejecuci√≥n

#### Contenido del PCB

- Identificaci√≥n (√∫nica en el sistema) 
- Identificadores varios del proceso (identificador del due√±o, padre, hijos, etc)
- Estado (ejecutando, listo, bloqueado) 
- Program Counter 
- Registros de CPU 
- Informaci√≥n para planificaci√≥n (p.ej., prioridad) 
- Informaci√≥n para administraci√≥n de memoria (p.ej., registros base y l√≠mite) 
- Informaci√≥n de I/O: dispositivos y recursos asignados al proceso, archivos abiertos en uso, etc. 
- Estad√≠sticas y otros: tiempo real y tiempo de CPU usado, etc. 
- Privilegios.
- Otros objetos vinculados al proceso.

### Transici√≥n de Estados de un Proceso

#### Tipos de Estados

Un proceso puede transitar por varios estados a lo largo de su vida dentro del sistema operativo:

- **Nuevo (New):** Se solicit√≥ al sistema operativo la creaci√≥n de un proceso, y sus recursos y estructuras est√°n siendo creadas.

- **Listo (Ready):** El proceso ya est√° preparado para ejecutarse, pero todav√≠a no se le ha asignado un procesador. Permanece en espera en la cola de procesos listos.

- **En Ejecuci√≥n (Running):** El proceso est√° siendo ejecutado en este momento. 

- **Bloqueado (Blocked):** El proceso no puede avanzar porque est√° esperando a que ocurra alg√∫n evento (como la finalizaci√≥n de una operaci√≥n de entrada/salida). Aunque haya un procesador disponible.

- **Zombie:** El proceso ha finalizado su ejecuci√≥n, pero el sistema operativo debe realizar ciertas operaciones de limpieza para poder eliminarlo de la lista.

- **Terminado (Exit):** El proceso termin√≥ de ejecutarse; sus estructuras est√°n a la espera de ser limpiadas por el sistema operativo.

#### Diagrama de Proceso

Un proceso puede pasar varias etapas diferentes en el sistema operativo, y el modelo depende del mismo. Hay varios modelos

##### Modelo 7 Estados

![](/imgs/clase-2/Modelo%207%20estados.png)

Se crea un nuevo proceso que debe ser admitido, este se puede poner en listo o en listo/suspendido (esperando memoria). Cuando esta listo, esta esperando que el S.O le otorgue el CPU para ponerlo en ejecuci√≥n. Cuando se encuentra en ejecuci√≥n pueden pasar 2 cosas, finaliza o se bloquea por una interrupci√≥n

##### Modelo 5 Estados

![](/imgs/clase-2/Modelo%205%20Estados.png)

Modelo mas sencillo, no existe los estados de listo/suspendido o bloqueado/suspendido

#### Colas

Una cola es una estructura de datos donde los elementos se agregan al final y se sacan del principio. El primero que entra es el primero que sale.

Aplicado a procesos, una cola es donde se organizan los procesos que est√°n esperando. Por ejemplo:
- Cuando un proceso pasa al estado Listo, se pone en la cola de Listos.
- Cuando un proceso est√° esperando por I/O, se pone en la cola de Bloqueados.

Todos los estados son de tipo cola, excepto los de ejecuci√≥n. Porque, el CPU solo puede ejecutar un proceso a la vez.

#### Clasificaci√≥n Estados

- **Estados Activos**

Son aquellos que compiten por el procesador o est√°n en condiciones de hacerlo. Estos son: ejecuci√≥n, listo y bloqueado (no pueden ejecutarse de momento por necesitar alg√∫n recurso ).

- **Estados Inactivos**

Son aquellos que no pueden competir por el uso del procesador. Estos son suspendido/bloqueado y suspendido/listo.

#### Razones de un Cambio de Estado de Proceso

- Interrupciones de Hardware Externas
- Excepci√≥n(trap)
- Llamada al sistema operativo
- Por finalizaci√≥n

### Creaci√≥n de Procesos

#### Razones para crear un proceso

Todos los procesos son creados por el sistema operativo, aunque un proceso puede crear otro proceso. Hay 4 razones para crear uno:
- La llegada de un trabajo nuevo al sistema.
- Un proceso enviado por un usuario.
- La necesidad de brindar un servicio a un programa en ejecuci√≥n.
- La creaci√≥n expl√≠cita por parte de otro proceso existente.

#### Tipos de Creacion de Procesos

Cuando un proceso crea a otro, el proceso creador se llama **padre** y el proceso generado se llama **hijo**. Estos procesos suelen **comunicarse** y **cooperar** entre s√≠.

- Jerarquia: Cada proceso que se crea es hijo del proceso creador y hereda el entorno de ejecuci√≥n de su padre. Puede ser de 2 maneras:
    - El padre continua ejecutando en paralelo con sus hijos
    - El padre espera que todos sus hijos hayan terminado y luego sigue √©l.
- No Jerarquica -> Se ejecutan de forma independiente

#### Secuencia de creaci√≥n de un proceso

1. Asignar un identificador al nuevo proceso
2. Asignar espacio memoria para el proceso
3. Incializar la estructura de datos PCB
4. Establecer enlaces apropiados con otras estructuras del sistema operativo, como archivos abiertos, referencias a procesos padres, hijos o hermanos.
5. Ampliar o crear otra estructura de datos en caso que fuerza necesarios (archivos y de m√°s)

#### Finalizar de un proceso

- Desaparece el PCB
- Liberar recursos comunes
- Recursos locales son destruidos: Los datos como variables o memoria del stack

La **Terminaci√≥n en cascada** es cuando un proceso termina (muere) tambien deben terminar sus hijos.

### Hilos

#### Definici√≥n

El concepto de **hilo** ya fue mencionado anteriormente, pero realizamos un repaso:

> Dentro de un proceso pueden existir **secciones independientes** (hilos), cada una con su propio espacio de registros, pila y contador de programa. Sin embargo, **comparten el espacio de memoria** con los dem√°s hilos del mismo proceso.

Hilos, threads o Proceso Liviano debido a que mantiene la estructura de un proceso con su PCB. Pero, dispone de estructuras,as peque√±as llamadas TCB (Thread Control Block, similar a PCB) que manejan menos informaci√≥n del PCB.

Cada hilo posee:
- TID (Thread Identifier)
- program counter (PC)
- registros de CPU
- Pila.

Cada hilo se ejecuta de forma **secuencial**, aunque en **multiprocesadores** pueden ejecutarse **en paralelo**.

Los hilos pueden **crear hilos hijos**, y **cooperan** entre s√≠ compartiendo:
- Espacio de Memoria
- Archivos Abiertos
- Relojes
- Otros recursos

#### Ventajas respecto a los Procesos

- Requiere **menos tiempo** realizar un cambio de contexto entre hilos que entre procesos.
- **Comparten espacio de memoria** y recursos, permitiendo una comunicaci√≥n m√°s r√°pida entre ellos.

#### Implementaci√≥n de Hilos

##### Hilos a Nivel de Usuario (ULT)

- **Caracteristicas**
  - Los administra el usuario mediante una aplicacion
  - Cualquier aplicaci√≥n puede ser programada para ser multi-hilo mediante el uso de librerias de hilos
  - Se crean en **tiempo de compilaci√≥n** y **no requieren intervenci√≥n del kernel**.
  - El kernel **no sabe** de la existencia de los hilos; ve al proceso como una sola entidad.
- **Ventajas**
  - El cambio de hilo no requiere modo kernel
  - El proceso no cambia a modo kernel para manejar el hilo
  - Puede correr en cualquier sistema operativo
  - El algoritmo de planificaci√≥n puede ser adapto sin molestar la planificaci√≥n del Sistema operativo
- **Desventajas**
  - la mayor√≠a de las llamadas a sistema son bloqueantes. Cuando un hilo ejecuta un llamadas a sistema no s√≥lo se bloquea ese hilo, sino que tambi√©n se bloquean todos los hilos del proceso.
  - Una aplicaci√≥n multi-hilo no puede tomar ventaja del multiprocesamiento; un kernel asigna un proceso a s√≥lo un procesador por vez.

##### Hilos a Nivel de Kernel

- **Caracteristicas**
  - El manejo de hilos es administrado por el kernel
  - Cualquier aplicaci√≥n puede ser programada para ser multi-hilo
  - No hay c√≥digo de manejo de hilo en el √°rea de aplicaci√≥n
- **Ventajas**
  - Las rutinas mismas del kernel pueden ser multi-hilo
  - Si un hilo se bloquea, el kernel planifica otro hilo del mismo proceso
  - Simult√°neamente, el kernel, puede planificar m√∫ltiples hilos del mismo proceso en m√∫ltiples procesadores
- **Desventajas**
  - La transferencia de control de un hilo a otro dentro del mismo proceso le requiere al kernel un cambio de modo.
  - **Mayor costo** en t√©rminos de tiempo y recursos del sistema operativo.
  
#### Estado de los Hilos

Los hilos pueden seguir los mismos estados que los procesos:
1. Listo(spawn)
2. Bloqueado
3. Ejecutando
4. Terminado

![](/imgs/clase-2/Estados%20Hilos.png)

#### Estructuras de Uso de los Hilos

- **Estructura Servidor Trabajador**

Un hilo act√∫a como **servidor** que recibe solicitudes de trabajo y las asigna a **hilos trabajadores** inactivos, despert√°ndolos para procesar las tareas.

![](/imgs/clase-2/Hilos%20Estructura%20servidor%20trabajador.png)

- **Estructura en Equipo**

Todos los hilos son **equivalentes** y **procesan sus propias solicitudes** de manera aut√≥noma.

![](/imgs/clase-2/Hilos%20estructura%20en%20equipo.png)

- **Estructura de Entubamiento(pipeline)**

El procesamiento de datos se realiza en **etapas**; Cada hilo procesa una parte de la tarea y pasa los resultados al siguiente hilo en la cadena.

Este modelo se asocia con el concepto de **Pipelining**, debido a la similitud en el flujo de datos.

![](/imgs/clase-2/Hilos%20Estructura%20Entubamiento.png)


## Modulo 3: Planificaci√≥n de Procesos

### Concepto de Planificaci√≥n

> Orden en que ira cediendo el uso del procesador a los processo que lo vayan solicitando, y a las politicas que empleara para que el uso que den a dicho tiempo no sea excesivo respecto al uso esperado del sistema

### Objetivos

- **Ser justo:**¬†Debe tratarse de igual manera a todos los procesos que compartan las mismas caracter√≠sticas, y nunca postergar indefinidamente uno de ellos (inanici√≥n o starvation)
- **Maximizar el rendimiento:**¬†Dar servicio a la mayor parte de procesos por unidad de tiempo
- **Ser predecible:** Un mismo trabajo debe tomar aproximadamente la misma cantidad de tiempo en completarse independientemente de la carga del sistema
- **Minimizar la sobrecarga:** El tiempo que el algoritmo pierda en burocracia (overhead)¬†debe mantenerse al m√≠nimo, dado que eÃÅste es tiempo de procesamiento √∫til perdido
- **Equilibrar el uso de recursos:** Favorecer a los procesos que empleen recursos subutilizados, penalizar a los que peleen por un recurso sobreutilizado causando contenci√≥n en el sistema
- **Evitar la postergaci√≥n indefinida (starvation):** Aumentar la prioridad de los procesos maÃÅs viejos, para favorecer que alcancen a obtener alg√∫n recurso por el cual est√©n esperando

### Tipos

- **A Largo Plazo**
  - Generacion de nuevos procesos
- **Mediano Plazo**
- **Extra largo plazo**

### Tipos de procesos

- CPU Bound -> operaciones que hacen uso del cpu 
- I/O Bounj -> hacen mas uso de entras y salidas que del cpu
- Procesos cortos .> Tipo I/O 